import glob
import sys
import time
import random
from pythonosc.udp_client import SimpleUDPClient as osc_client
from pythonosc.dispatcher import Dispatcher
from pythonosc import osc_server
from pynput import keyboard # to monitor the release of the Ctrl key
import notochord
import argparse

INITINST = 257
MINVELDIFF = 5
QUANTIZE_DUR = 16 # we quantize based on the 16th note
OSCDEL = 0.15

time_stamp = 0

model = notochord.Notochord.from_checkpoint('notochord-latest.ckpt')
model.eval()
model.reset()

notes = {'c': 48, 'd': 50, 'e': 52, 'f': 53, 'g': 55, 'a': 57, 'b': 59, 'r': -1}
accidentals = {'es': -1, 'is': 1}
durations = [1, 2, 4, 8, 16, 32, 64]
velocities = {'ppp': 16, 'pp': 32, 'p': 48, 'mp': 64, 'mf': 80, 'f': 96, 'ff': 112, 'fff': 127}

"""
The dictionary below is specific to the church organ
It is mainly intended to be able to write the left hand in the F clef
but having the organ sound at the desired pitch by opening the correct stops that sound an octave or two higher
The dict keys are the MIDI channel of each manual and the values are dictionaries
with number of octaves higher as keys and the values are stops
"""
stops = {3: {-1: 0, 0: 2, 1: 10, 2: 12},
		 2: {0: 0, 1: 6, 2: 10},
		 1: {-1: 0, 0: 2, 1: 10, 2: 14},
		 8: {-1: 0, 0: 6, 1: 10}}

"""
Also for the organ, use a dictionary as a map to the MIDI channels
and another dict to stop the octaves to be set via stops
"""
midi_chans = {0: 1, 1: 2, 2: 3, 3: 8}
stop_octaves = {0: 0, 1: 0, 2: 0, 3: 0}

"""
Pitch list to constrain Notochord, change according to needs
"""
included_pitches = list(range(36, 97))

# store loop names so I can query them when something that sounds good comes up
loop_names = []

tempo = 120
tempo_ms = 500
numer = 4
denom = 4
beatat = 4
barnum = 1

# the two dictionaries below are populated in the main function through command line arguments
# give anonymous instrument indexes
insts = dict()
# and the reverse dictionary with zero-based indexes
insts_rev = dict()
# the lists below is needed if we're writing for a duo
written_base_insts = []
written_secondary_insts = []

NUMINSTS = 0

ctrl_pressed_l = False
ctrl_pressed_r = False

# the list below stores the lines generated by Notochord so they can be fed back to the network
gen_lines = []

# recursion is used in rhythm quantization, so we reduce the recursion limit from 1000 (default) to 100
sys.setrecursionlimit(100)


# keyboard monitoring functions
# monitoring the ctrl key helps LiveLily avoid confusing whether it is pressed
# while Notochord is typing in its input
# when confused (because the ctrl key is pressed with Return to execute the OSC command to activate Notochord)
# and the "f" character is pressed, LiveLily goes into fullscreen mode and skips the character
# and the "p" character swaps the position of the score
# check the generate() function to see how this is used
def on_press(key, injected):
	global ctrl_pressed_l, ctrl_pressed_r
	try:
		dummy = key.char
	except AttributeError:
		if key == keyboard.Key.ctrl:
			ctrl_pressed_l = True
		elif key == keyboard.Key.ctrl_r:
			ctrl_pressed_r = True


def on_release(key, injected):
	global ctrl_pressed_l, ctrl_pressed_r
	if key == keyboard.Key.ctrl:
		ctrl_pressed_l = False
	elif key == keyboard.Key.ctrl_r:
		ctrl_pressed_r = False


def store_bar_lines(composer, lines):
	bar_nr = 0
	starting_line = 0
	local_dict = dict()
	for i,line in enumerate(lines):
		if line.startswith("\\bar"):
			bar_nr = int(line[5:line[5:].find(" ")+5])
			starting_line = i+1
		elif line == "}\n":
			local_dict[bar_nr] = [starting_line, i]
	return local_dict


def get_dur(lyv_str):
	digit_str = lyv_str[0]
	num_dots = 0
	if len(lyv_str) > 1:
		if lyv_str[1].isdigit():
			digit_str += lyv_str[1]
		elif lyv_str[1] == '.':
			num_dots += 1
		if len(lyv_str) > 2:
			if lyv_str[2] == '.':
				is_dotted = True
	dur = int(digit_str)
	if dur in durations:
		return dur, num_dots
	else:
		return None


def get_note(lyv_str, ndx):
	note = None
	if ndx > 0:
		if lyv_str[ndx-1] == "\\" or lyv_str[ndx-1] == 'f' or lyv_str[ndx-1] == 'm':
			return note
	if len(lyv_str[ndx:]) > 1:
		# make sure the current character is not part of an accidental
		if lyv_str[ndx:ndx+2] not in accidentals.keys():
			note = notes[lyv_str[ndx]]
			if len(lyv_str[ndx:]) > 2:
				if lyv_str[ndx+1:ndx+3] in accidentals.keys():
					# figure out if the current note has an accidental
					note += accidentals[lyv_str[ndx+1:ndx+3]]
	return note


def get_velocity(lyv_str):
	velocity = None
	if len(lyv_str) > 1:
		if lyv_str[1] == 'f' or lyv_str[1] == 'p' or lyv_str[1] == 'm':
			velocity = lyv_str[1]
			if len(lyv_str) > 2:
				for ch in lyv_str[2:]:
					if ch == 'f' or ch == 'p':
						velocity += ch
					else:
						break
	if velocity is None:
		return None
	else:
		return velocities[velocity]


def parse_string(lyv_str):
	prev_dur = 0
	prev_vel = 72 # middle velocity
	num_notes = 0 # counts notes vertically
	in_chord = False
	chord_ndx = -1
	parsed_notes = []
	chord_notes = dict()
	for i,ch in enumerate(lyv_str):
		if ch == "<":
			in_chord = True
		elif ch == ">":
			in_chord = False
			num_notes = 0
		elif ch in notes.keys():
			note = get_note(lyv_str, i)
			if note is not None:
				if not in_chord or (in_chord and num_notes == 0):
					parsed_notes.append([note, prev_dur, False, prev_vel])
					chord_ndx += 1
					if in_chord:
						num_notes += 1
				elif in_chord:
					if chord_ndx not in chord_notes.keys():
						chord_notes[chord_ndx] = []
					chord_notes[chord_ndx].append(note)
					num_notes += 1
		elif ch.isdigit():
			dur_dot = get_dur(lyv_str[i:])
			if dur_dot is not None:
				parsed_notes[-1][1] = dur_dot[0]
				parsed_notes[-1][2] = dur_dot[1]
				prev_dur = dur_dot[0]
		elif ch == "\\":
			velocity = get_velocity(lyv_str[i:])
			if velocity is not None:
				parsed_notes[-1][3] = velocity
				prev_vel = velocity
		elif ch == "'" or ch == ",":
			if ch == "'":
				if not in_chord or (in_chord and num_notes == 1):
					parsed_notes[-1][0] += 12
					if parsed_notes[-1][0] > 127: parsed_notes[-1][0] -= 12
				elif in_chord:
					chord_notes[chord_ndx][-1] += 12
					if chord_notes[chord_ndx][-1] > 127: chord_notes[chord_ndx][-1] -= 12
			else:
				if not in_chord or (in_chord and num_notes == 1):
					parsed_notes[-1][0] -= 12
					if parsed_notes[-1][0] < 0: parsed_notes[-1][0] += 12
				elif in_chord:
					chord_notes[chord_ndx][-1] -= 12
					if chord_notes[chord_ndx][-1] < 0: chord_notes[chord_ndx][-1] += 12
	return parsed_notes, chord_notes


def BPM2ms(tempo):
	return 1000 / (tempo / 60)


def ms2BPM(dur):
	return (1000 / dur) * 60


def parse_bar(*args):
	global tempo, tempo_ms, numer, denom, beatat, gen_lines
	duo = args[0]
	choose_from_prev = False
	if len(args) == 5:
		# with five arguments we explicitly pass the composer and bar number of a fixed composition
		composer = args[1]
		bar_nr = args[2]
		all_lyv_lines = args[3]
		bars_dict = args[4]
		lines = all_lyv_lines[composer][bars_dict[composer][bar_nr][0]:bars_dict[composer][bar_nr][1]]
	elif len(args) == 2:
		# with two arguments we pass the strings of a bar definition inside LiveLily
		lines = args[1]
	else:
		# with one argument (the duo boolean) we want to use the previous output of the network
		lines = gen_lines
		choose_from_prev = True
	strings_to_replace = ["clef", "treble", "bass", "alto", "\\ottava", "\\ott", "-2", "-1", "0", "1", "2"]
	insts_local = dict()
	chord_notes = dict()
	for line in lines:
		if line.endswith("\n"): line = line[:-1]
		# remove the four white spaces that comprise a horizontal tab
		while line.startswith(" "):
			line = line[1:]
		if line.startswith("\\tempo"):
			if "=" in line:
				tempo = int(line[line.find("=")+1:])
			else:
				tempo = int(line[7:])
			tempo_ms = BPM2ms(tempo)
		elif line.startswith("\\time"):
			numer = int(line[6:line[6:].find("/")+6])
			denom = int(line[line.find("/")+1:])
			beatat = denom # for safety, in case beatat has not been explicitly set
		elif line.startswith("\\beatat"):
			beatat = int(line[8:])
		else:
			if duo and choose_from_prev:
				inst_name = line[:line.find(" ")-1]
				remove_char = 1
			else:
				inst_name = line[:line.find(" ")]
				remove_char = 0
			if inst_name in insts.keys():
				# remove clefs and ottavas from string
				items = line.split()
				for string in strings_to_replace:
					while string in items:
						items.remove(string)
				line = ' '.join(items)
				# done removing
				this_inst = line[:line.find(" ")-remove_char]
				line = line[line.find(" ")+1:]
				# the first item of the list in the dict value is the instrument index in general midi
				# then we append the list of lists with the data for each note in a bar, inside another list
				# so we end up with a list of this kind (items are MIDI note, duration - quarter, eighth, etc. -,
				# number of dots, and velocity):
				# [1, [[60, 4, 0, 72], [62, 8, 1, 112], [64, 16, 0, 64], [65, 2, 0, 48]],
				#      [67, 2, 0, 64], [69, 2, 0, 80]]
				# in the example above we have stored two bars for instrument 1, and each bar has a list
				# with the necessary data for the feed() method of a notochord model
				data, chord_notes_dict = parse_string(line)
				chord_notes[insts[this_inst][0]] = chord_notes_dict
				list_to_store = []
				for datum in data:
					actual_dur = (denom / datum[1]) * tempo_ms
					stored_dur = actual_dur
					for i in range(datum[2]):
						stored_dur += (actual_dur * 0.5)
						actual_dur *= 0.5
					list_to_store.append([datum[0], stored_dur, datum[3]])
				insts_local[this_inst] = [insts[this_inst][0], list_to_store]
	return insts_local, numer, tempo_ms, chord_notes


def get_sorted_events(parsed_data, numer, tempo_ms, chord_notes):
	events = []
	for key in parsed_data.keys():
		for event in parsed_data[key][1]:
			event.insert(0, parsed_data[key][0])
			events.append(event)
	# correct the time durations where the first event starts at time 0
	# and the next event starts at time equal to the duration of the first event
	# the rest of the events take accumulating time stamps
	prev_dur = 0
	inst_ndx = 0
	events_accum_dur = []
	for event in events:
		if event[0] != inst_ndx:
			inst_ndx = event[0]
			prev_dur = 0
		prev_dur_copy = prev_dur
		# accumulate the time stamp of the event
		prev_dur += event[2]
		event[2] = prev_dur_copy
		events_accum_dur.append(event)
	# insert the index of each event, so we can query it later to insert chord notes
	note_ndx = 0
	inst_ndx = 0
	for i,event in enumerate(events_accum_dur):
		if event[0] != inst_ndx:
			note_ndx = 0
			inst_ndx = event[0]
		event.insert(1, note_ndx)
		events_accum_dur[i] = event
		note_ndx += 1
	# once we correct the time stamps, we add the note off events
	# this is determined by the difference between the time stamp of the next event
	# and that of the current event, split by 75-25%
	events_w_note_off = []
	for i,event in enumerate(events_accum_dur):
		if i < len(events_accum_dur) - 1:
			if events_accum_dur[i+1][0] != event[0]:
				actual_dur = (numer * tempo_ms) - event[3]
			else:
				actual_dur = events_accum_dur[i+1][3] - event[3]
		else:
			actual_dur = (numer * tempo_ms) - event[3]
		note_on_dur = actual_dur * 0.75
		events_w_note_off.append(event)
		events_w_note_off.append([event[0], event[1], event[2], event[3]+note_on_dur, 0])
	# then we remove the events with rests, and correct the time stamps again
	# in this loop we don't accumulate time stamps as this has already been done
	events_no_rests = []
	for event in events_w_note_off:
		if event[2] != -1:
			events_no_rests.append(event)
	# sort events based on time of occurrence
	events_no_rests.sort(key=lambda x: x[3])
	# once sorted, insert the chord notes
	events_w_chords = []
	for event in events_no_rests:
		events_w_chords.append(event)
		if event[0] in chord_notes.keys():
			if event[1] in chord_notes[event[0]].keys():
				for note in chord_notes[event[0]][event[1]]:
					events_w_chords.append([event[0], event[1], note, event[3], event[4]])
	return events_w_chords


def get_dur_of_this_event(inst, event_ndx, events_per_inst, next_event, total_dur):
	# to get the duration of the current event we need to loop till we find a velocity > 0
	# still, we need to accumulate delta times of note off events
	dt = next_event["dt"]
	loopndx = event_ndx + 2
	last_dur_from_total = True
	events_len = len(events_per_inst[inst])
	#if loopndx >= events_len: last_dur_from_total = True
	while loopndx < events_len:
		dt += events_per_inst[inst][loopndx]["dt"]
		if events_per_inst[inst][loopndx]["vel"] > 0 and events_per_inst[inst][loopndx]["dt"] > 0:
			last_dur_from_total = False
			break
		loopndx += 1
	return dt, last_dur_from_total


def correct_durs(quantize_base_units, total_quantize_dur):
	dur_diff = total_quantize_dur - sum(quantize_base_units)
	add_or_remove = 1
	if dur_diff < 0:
		add_or_remove = -1
		dur_diff = abs(dur_diff)
	# find which durations are odd
	odd_ndxs = []
	for i,v in enumerate(quantize_base_units):
		if v % 2 > 0:
			odd_ndxs.append(i)
	if dur_diff == 0:
		# add one to a duration and remove one from the next
		# so run a loop every other list item
		for i in range(0, len(odd_ndxs), 2):
			if quantize_base_units[odd_ndxs[i]] + 1 > 0 and quantize_base_units[odd_ndxs[i+1]] - 1 > 0:
				quantize_base_units[odd_ndxs[i]] += 1
				quantize_base_units[odd_ndxs[i+1]] -= 1
			elif quantize_base_units[odd_ndxs[i]] - 1 > 0 and quantize_base_units[odd_ndxs[i+1]] + 1 > 0:
				quantize_base_units[odd_ndxs[i]] -= 1
				quantize_base_units[odd_ndxs[i+1]] += 1
	else:
		while dur_diff > 0:
			if len(odd_ndxs) == 0:
				# if there are no odd numbers in the durations, we import all indexes
				for i in range(len(quantize_base_units)):
					odd_ndxs.append(i)
			# if the duration difference is negative, which means we have to remove units of durations
			# we have to check if the sum of odd durations is greater than the amount of duration units we need to remove
			odd_sum = 0
			for ndx in odd_ndxs:
				odd_sum += quantize_base_units[ndx]
				# subtract 1 for every odd duration because we don't want to zero a duration
				# this is for the if test below (dur_diff > odd_sum)
				odd_sum -= 1
			if add_or_remove < 0 and dur_diff > odd_sum:
				for ndx in odd_ndxs:
					# try to reduce every item to two duration units
					units_to_remove = min(dur_diff, quantize_base_units[ndx] - 2)
					quantize_base_units[ndx] -= units_to_remove
					dur_diff -= units_to_remove
				# if there are remaining units to remove, try to make all durations two duration units
				if dur_diff > 0:
					for ndx,unit in enumerate(quantize_base_units):
						units_to_remove = min(dur_diff, quantize_base_units[ndx] - 2)
						quantize_base_units[ndx] -= units_to_remove
						dur_diff -= units_to_remove
				# exit the while loop here
				break
			for ndx in odd_ndxs:
				if dur_diff > 0 and quantize_base_units[ndx] + add_or_remove >= 1:
					quantize_base_units[ndx] += add_or_remove
					dur_diff -= 1
				if dur_diff == 0:
					break
		# the method above might still result in a list with odd numbers
		# in this case we call this function recursively with 0 difference
		odd_ndxs = []
		for i,v in enumerate(quantize_base_units):
			if v % 2 > 0 and v > 1:
				odd_ndxs.append(i)
		if len(odd_ndxs) > 0:
			print("odd durations present, calling recursively...")
			quantize_base_units = correct_durs(quantize_base_units, total_quantize_dur)
		# we also check if the sum of the quantized durations is indeed correct
		# because it might still be wrong
		if sum(quantize_base_units) != total_quantize_dur:
			print("quantized durations sum incorrect, calling recursively...")
			quantize_base_units = correct_durs(quantize_base_units, total_quantize_dur)
	# check if we have any 0 durations in our list
	if 0 in quantize_base_units:
		zero_ndxs = []
		for ndx,unit in enumerate(quantize_base_units):
			if unit == 0: zero_ndxs.append(ndx)
		for ndx in zero_ndxs:
			break_from_loop = False
			for ndx2,unit in enumerate(quantize_base_units):
				if ndx2 not in zero_ndxs:
					# if we find a duration unit larger than 2 that is even
					if unit > 2 and unit % 2 == 0:
						# take 2 from that unit and add it to the 0 unit
						quantize_base_units[ndx] += 2
						quantize_base_units[ndx2] -= 2
						# once we find an index that has a value breater than 0 (not in the zero_ndxs list)
						# exit the loop
						break_from_loop = True
				if break_from_loop:
					break
	return quantize_base_units


def translate_to_livelily(events, duo):
	global tempo, numer, denom, barnum, insts_rev, time_stamp, gen_lines, written_base_insts, written_secondary_insts, stop_octaves
	notes = ["c", "cis", "d", "dis", "e", "f", "fis", "g", "gis", "a", "bes", "b"]
	dynamics = {16: "\\ppp", 32: "\\pp", 48: "\\p", 64: "\\mp", 80: "\\mf", 96: "\\f", 112: "\\ff", 127: "\\fff"}
	quantize_base = 125 # for a sixteenth at 4 = 120
	# create a dict with the instrument indexes as keys
	events_per_inst = dict()
	for event in events:
		inst = event[0]
		# it might happen that the instrument index negative so we filter this out
		if inst < 0:
			continue
		if inst not in events_per_inst.keys():
			# create a dict for every instrument with event indexes as keys
			events_per_inst[inst] = dict()
		event_ndx = len(events_per_inst[inst])
		# sometimes the notochord model outputs a "chord" with the same note repeated
		# so we filter it out with the if test below
		# event[3] is the delta time, and a 0 delta time means either the very beginning
		# or an event synchronized with the previous event
		# event[1] is the MIDI note and events_per_inst[key][event_ndx-1]["note"] is the last stored MIDI note
		store_event = True
		if event[3] == 0 and event_ndx > 0:
			if event[1] == events_per_inst[inst][event_ndx-1]["note"]:
				store_event = False
		# also, notochord might produce a note off without its prior note on
		# so we need to filter that out as well
		if event[2] == 0 and event_ndx > 0:
			if event[1] not in events_per_inst[inst][event_ndx-1].values():
				store_event = False
			else:
				# the loop below will iterate as many times as the items of the events_per_inst dictionary
				# assigning a decrementing value to i, but finishing at 1, so we need to do i-1 to properly index
				for i in range(len(events_per_inst[inst]), 0, -1):
					# if the current note off already exists as a note off, we should not store this event
					if events_per_inst[inst][i-1]["note"] == event[1] and events_per_inst[inst][i-1]["vel"] == 0:
						store_event = False
						break
		if not store_event:
			continue
		events_per_inst[inst][event_ndx] = dict()
		# an event holds the instrument index, the MIDI note, the velocity and the duration in ms
		for i,item in enumerate(event):
			if i > 0:
				if i == 1:
					events_per_inst[inst][event_ndx]["note"] = item
				elif i == 2:
					events_per_inst[inst][event_ndx]["vel"] = item
				else:
					# quantize duration based on the duration of the quantization
					mindur = QUANTIZE_DUR / beatat
					quantize_base = int(BPM2ms(tempo) / mindur)
					counter = 1
					if item == 0:
						events_per_inst[inst][event_ndx]["dt"] = item
					else:
						while item > quantize_base * counter:
							counter += 1
						events_per_inst[inst][event_ndx]["dt"] = quantize_base*counter
	for inst in events_per_inst.keys():
		try:
			print(f"inst: {insts_rev[inst]}")
			for event_ndx in events_per_inst[inst].keys():
				print(f"event {event_ndx}: {events_per_inst[inst][event_ndx]}")
		except KeyError:
			return None
	# now that we have sorted the data based on instrument and event
	# we can build the LiveLily strings by converting ms duration to Western-music score durations
	total_dur = round(numer * BPM2ms(tempo))
	#print(f"tempo: {tempo}, BPM to ms: {BPM2ms(tempo)}, total dur: {total_dur}")
	lyv_strings = []
	for inst in events_per_inst.keys():
		print(f"creating LiveLily string for inst {insts_rev[inst]}")
		lyv_str = ""
		""" lyv_str2 is specific to Sveinn's performance """
		lyv_str2 = ""
		dur_accum = 0
		last_dur_from_total = False
		events_len = len(events_per_inst[inst])
		durs = []
		notes_on = []
		dyns = []
		# chord notes are stored in a dict with the event index as the key
		# and a list with the chord notes (excluding the root note) as the value
		chords = dict()
		for i,(event_ndx,this_event) in enumerate(events_per_inst[inst].items()):
			dur_accum += this_event["dt"]
			# for now write only noteOn events
			if this_event["vel"] > 0:
				is_chord = False
				# a delta time of 0 for an event that's not the first means that we have a chord
				if this_event["dt"] == 0 and i > 0 and len(notes_on) > 0:
					is_chord = True
				if not is_chord:
					notes_on.append(this_event["note"])
					dyns.append(this_event["vel"])
					if len(dyns) > 1:
						if abs(dyns[-1] - dyns[-2]) < MINVELDIFF:
							dyns[-1] = dyns[-2]
					if i < events_len - 1:
						next_event = events_per_inst[inst][event_ndx+1]
						if next_event["vel"] == 0:
							dur, last_dur_from_total = get_dur_of_this_event(inst, event_ndx, events_per_inst, next_event, total_dur)
							if last_dur_from_total:
								dur = total_dur - dur_accum
							durs.append(dur)
						else:
							if next_event["dt"] == 0:
								dur, last_dur_from_total = get_dur_of_this_event(inst, event_ndx, events_per_inst, next_event, total_dur)
								if last_dur_from_total:
									dur = total_dur - dur_accum
								durs.append(dur)
							else:
								durs.append(next_event["dt"])
					else:
						durs.append(total_dur - dur_accum)
						last_dur_from_total = True
				# make sure the first chord note is not the same as the root of the chord
				elif this_event["note"] != notes_on[-1]:
					if len(notes_on)-1 not in chords.keys():
						chords[len(notes_on)-1] = []
					# make sure this chord note doesn't already exist in this chord
					if this_event["note"] not in chords[len(notes_on)-1]:
						chords[len(notes_on)-1].append(this_event["note"])
		if last_dur_from_total:
			# to compensate for the last duration, in case it occured by subtracting the duration accumulation
			# from the total duration
			# due to notochord outputting a coherent number of notes (according to its feed)
			# but with rather short durations
			# we replace it with the duration that appears the most in the durs list
			durs_popularity = dict()
			for dur in durs:
				if dur > 0:
					num_rep = durs.count(dur)
					# we store a duration only if it is an integer multiple of the quantization base
					# hence dur % quantize_base
					if num_rep not in durs_popularity.keys() and dur % quantize_base == 0:
						durs_popularity[num_rep] = []
					if num_rep in durs_popularity.keys():
						if dur not in durs_popularity[num_rep]:
							durs_popularity[num_rep].append(abs(dur))
			if len(durs_popularity) > 0:
				# durs_popularity results in a dictionary with the number of repetitions as keys
				# and a list with durations that appear as many times in the durs list as their key
				# e.g. {3: [178], 2: [356], 1: [0, 1078]}
				# in the example above we have one time a 0 and one time a large value that resulted from what is stated above
				# we can now replace the last value of durs with the most popular duration
				durs_popularity_keys = durs_popularity.keys()
				max_key = max(durs_popularity_keys)
				# get the minimum value of the stored values in the most popular list
				# this is because we might get two notes only with the second note having its duration set
				# by the difference between the accumulation and the total duration, and choosing a radnom duration
				# will not work in this case, as this difference might be chosen
				durs[-1] = min(durs_popularity[max_key])
			else:
				durs[-1] = quantize_base
		one_note = False
		tacet = False
		stop_octave = 0
		clef = "treble"
		clef2 = "treble"
		notes_on2 = []
		"""
		this is specific for Sveinn's performance
		"""
		# for the organ we want only the top manual to be in the G clef
		# all others should be in the F clef
		if inst > 0:
			clef2 = "bass"
			# we also want to constrain the pitch ranges
			for note in notes_on:
				if inst == 0:
					if note < 57:
						while note < 57: note += 12
					elif note > 84:
						while note > 84: note -= 12
				else:
					if note < 36:
						while note < 36: note += 12
					elif note > 64:
						while note > 64: note -= 12
				notes_on2.append(note)
		"""
		done
		"""
		if len(notes_on) > 0:
			notes_middle = sum(notes_on) / len(notes_on)
			if notes_middle < 60:
				clef = "bass"
		if len(notes_on) == 1:
			one_note = True
		else:
			# before we start writing the LiveLily string, we need to correct the durations so they properly fit the bar we're creating
			# we do this by getting the number of QUANTIZE_DUR each duration has and use that as a percentage
			# for the total duration of the bar we're creating
			quantize_base_units = []
			for dur in durs:
				quantize_base_units.append(int(dur / quantize_base))
			total_quantize_dur = int((QUANTIZE_DUR / denom) * numer)
			if len(quantize_base_units) == 0:
				tacet = True
			if not tacet:
				# most likely, the durations of the generated notes will not fit the total duration
				# of the bar we're creating so we need to add or remove some QUANTIZE_DUR units for some notes
				# but even if there is no duration difference, we pass the duration list through the correct_durs function
				# because our list might contain odd numbers greater than 1 duration unit
				try:
					durs = correct_durs(quantize_base_units, total_quantize_dur)
				except RecursionError:
					# in case of maximum recursion depth, we return so we try again outside of this function
					return None
		prev_closest_key = -1
		if not tacet:
			for ndx,note in enumerate(notes_on):
				this_note_str = None
				temp_lyv_str = ""
				""" temp_lyv_str2 is specific to Sveinn's performance """
				temp_lyv_str2 = ""
				num_notes = 1
				lyv_str += " "
				lyv_str2 += " "
				if ndx in chords.keys():
					temp_lyv_str += "<"
					"""
					this is specific for Sveinn's performance
					"""
					if inst < 2:
						temp_lyv_str2 += "<"
					"""
					done
					"""
					num_notes += len(chords[ndx])
				for j in range(num_notes):
					this_note = None
					if j == 0: this_note = note
					else: this_note = chords[ndx][j-1]
					this_note_str = notes[this_note % 12]
					if j > 0:
						temp_lyv_str += " "
						"""
						this is specific for Sveinn's performance
						"""
						if inst < 2 and j < 2:
							temp_lyv_str2 += " "
						"""
						done
						"""
					temp_lyv_str += this_note_str
					"""
					this is specific for Sveinn's performance
					"""
					if inst < 2 and j < 2:
						temp_lyv_str2 += this_note_str
					elif inst == 2 and j == 0:
						temp_lyv_str2 += this_note_str
					"""
					done
					"""
					octave_str = None
					this_octave = 0
					if this_note > 48: octave_str = "'"
					else: octave_str = ","
					num_octaves = int(abs(this_note-48) / 12)
					for octave in range(num_octaves):
						temp_lyv_str += octave_str
						"""
						this is specific for Sveinn's performance
						"""
						if inst < 2 and j < 2:
							temp_lyv_str2 += octave_str
						elif inst == 2 and j == 0:
							temp_lyv_str2 += octave_str
						"""
						done
						"""
				if ndx in chords.keys():
					temp_lyv_str += ">"
					"""
					this is specific for Sveinn's performance
					"""
					if inst < 2:
						temp_lyv_str2 += ">"
					"""
					done
					"""
				remaining_dur = 0
				if one_note:
					durs[ndx] = int((numer / denom) * QUANTIZE_DUR)
				try:
					print_dur = durs[ndx]
					while (QUANTIZE_DUR / print_dur) % 1 > 0:
						print_dur -= 2
						remaining_dur += 2
					dur = int(QUANTIZE_DUR / print_dur)
				except (ZeroDivisionError, IndexError) as e:
					print(f"got {e} error for {ndx}")
					dur = 1
				lyv_str += (temp_lyv_str + str(dur))
				"""
				all lyv_str2 stuff is specific for Sveinn's performance
				"""
				lyv_str2 += (temp_lyv_str2 + str(dur))
				dyn_keys = list(dynamics.keys())
				closest_key = min(dyn_keys, key=lambda x:abs(x-dyns[ndx]))
				# the organ doesn't need dynamics
				#if closest_key != prev_closest_key:
				#	lyv_str += dynamics[closest_key]
				# check if there is any remaining duration and add tied notes
				if remaining_dur > 0:
					lyv_str += "~"
					lyv_str2 += "~"
					while (QUANTIZE_DUR / remaining_dur) % 1 > 0:
						lyv_str += (" " + temp_lyv_str)
						lyv_str += (str(int(QUANTIZE_DUR / 2)) + "~")
						lyv_str2 += (" " + temp_lyv_str2)
						lyv_str2 += (str(int(QUANTIZE_DUR / 2)) + "~")
						remaining_dur -= 2
					lyv_str += (" " + temp_lyv_str)
					lyv_str += str(int(QUANTIZE_DUR / remaining_dur))
					lyv_str2 += (" " + temp_lyv_str2)
					lyv_str2 += str(int(QUANTIZE_DUR / remaining_dur))
				prev_closest_key = closest_key
		else:
			lyv_str += " r1"
			lyv_str2 += " r1"
		lyv_str_to_append = None
		"""
		done with lyv_str2, strings_to_append and string_ndx are also specific to Sveinn's performance
		without these we just use lyv_str instead of strings_to_append[string_ndx]
		the same applies to clefs[clef_ndx], without these we just use clef
		"""
		strings_to_append = [lyv_str, lyv_str2]
		string_ndx = 0
		clefs = [clef, clef2]
		clef_ndx = 0
		if duo:
			# if we're writing for a duo, determine whether we'll append 1 or 2 to the instrument name
			if inst not in written_base_insts and inst not in written_secondary_insts:
				lyv_str_to_append = insts_rev[inst] + "1"
				written_base_insts.append(inst)
			elif inst in written_base_insts and inst not in written_secondary_insts:
				lyv_str_to_append = insts_rev[inst] + "2"
				written_secondary_insts.append(inst)
				string_ndx = 1
				clef_ndx = 1
			else:
				return None
		else:
			lyv_str_to_append = insts_rev[inst]
		lyv_str_to_append += (" clef " + clefs[clef_ndx] + strings_to_append[string_ndx])
		lyv_strings.append(lyv_str_to_append)
	return lyv_strings


def type_lyv_strigs(client, duo, lyv_strings):
	global gen_lines, barnum
	# sort strings to write the instruments in order
	shuffled_ndxs = []
	for i,string in enumerate(lyv_strings):
		tokens = string.split()
		# get the first token of the string which is the instrument name
		# and subtract INITINST to make it zero-based
		# the insts dict contains single element lists, hence insts[tokens[0]][0]
		if duo:
			shuffled_ndxs.append(insts[tokens[0][:-1]][0]-INITINST)
		else:
			shuffled_ndxs.append(insts[tokens[0]][0]-INITINST)
	# then sort the lyv strings based on the shuffled indexes
	sorted_strings = [val for _, val in sorted(zip(shuffled_ndxs, lyv_strings))]
	# store the sorted strings so they can be fed back to the network
	gen_lines = sorted_strings.copy()
	#print(f"time before typing: {time.time() - time_stamp}")
	barstr = "\\bar nn" + str(barnum) + " {"
	for ch in barstr:
		client.send_message("/livelily2/press", ch)
	client.send_message("/livelily2/press", 13)
	# type the horizontal tab once, the rest will be imported by LiveLily
	client.send_message("/livelily2/press", 9)
	tempostr = "\\tempo " + str(tempo)
	for ch in tempostr:
		client.send_message("/livelily2/press", ch)
	client.send_message("/livelily2/press", 13)
	timestr = "\\time " + str(numer) + "/" + str(denom)
	for ch in timestr:
		client.send_message("/livelily2/press", ch)
	client.send_message("/livelily2/press", 13)
	for counter,string in enumerate(sorted_strings):
		for ch in string:
			client.send_message("/livelily2/press", ch)
		print(string)
		client.send_message("/livelily2/press", 13)
	# a tab is inserted by LiveLily, so we delete it by sending the backspace ASCII value
	# before we send the closing bracket
	client.send_message("/livelily2/press", 8)
	client.send_message("/livelily2/press", "}")
	execute_line(client)
	barnum += 1


def find_hanging(notes, client):
	# find out which notes are left hanging without the model having predicted their note off
	notes_on = dict()
	for note in notes:
		if note[2] > 0:
			if note[0] not in notes_on.keys():
				notes_on[note[0]] = []
			if note[1] not in notes_on[note[0]]: notes_on[note[0]].append(note[1])
		elif note[0] in notes_on.keys():
			if note[1] in notes_on[note[0]]:
				ndx = notes_on[note[0]].index(note[1])
				del(notes_on[note[0]][ndx])
	for inst in notes_on.keys():
		for note in notes_on[inst]:
			client.send_message("/remaining", [inst, note])


def generate(address, fixed_args, *osc_args):
	"""
	This function gets OSC input from LiveLily and generates bars
	It is called with one of the following argument combinations
	num_bars(int) composer_name bar_nr(int) num_notes(int) "r"
	num_bars(int) composer_name bar_nr(int) num_notes(int)
	num_bars(int) num_notes(int)

	The first two use the name of a composer to get a bar from a fixed composition as a feed
	The "r" character denotes a recursive mode, where after the first generated bar,
	the network will be fed its previous output.
	Without this, each bar will be generated with the given bar from the fixed composition as a feed
	The last combination uses Notochord's internal feed with query_feed() (which is always called to query a new MIDI event)
	"""
	global barnum, time_stamp, ctrl_pressed_l, ctrl_pressed_r, gen_lines, written_base_insts, written_secondary_insts
	# stall the function while the ctrl key is pressed to avoid confusion
	while ctrl_pressed_l or ctrl_pressed_r:
		print("ctrl pressed, waiting...")
		time.sleep(0.1)
	# print a blank line to separate data
	print()
	time_stamp = time.time()
	all_lyv_lines = fixed_args[0]
	bars_dict = fixed_args[1]
	client = fixed_args[2]
	duo = fixed_args[3]
	num_args = len(osc_args)
	num_bars = osc_args[0]
	num_notes = [0, 0]
	feed = True
	recursive = False
	if num_args < 4:
		feed = False
		num_notes = osc_args[1]
		if num_args == 3: num_notes[1] = osc_args[4]
		else: num_notes[1] = num_notes[0]
	elif num_args > 3:
		# empty gen_lines in case of recursion error, so they don't hold old data
		gen_lines = []
		recursive = True
		composer = osc_args[1]
		bar_nr = osc_args[2]
		num_notes[0] = osc_args[3]
		if num_args == 4: num_notes[1] = num_notes[0]
		elif num_args == 5:
			if type(osc_args[4]) is str:
				recursive = True
				num_notes[1] = num_notes[0]
			else:
				num_notes[1] = osc_args[4]
		elif num_args == 6: num_notes[1] = osc_args[4]
	start_of_loop = barnum
	lyv_strings = []
	if duo:
		# if we're writing for a duo (twice the defined instruments), empty the list below so it's useable in translate_to_livelily()
		written_base_insts = []
		written_secondary_insts = []
		num_bars *= 2
	for i in range(num_bars):
		if feed:
			if i == 0 or len(gen_lines) == 0:
				# the first iteration will feed the network a bar from a fixed composition
				feed_model(duo, composer, bar_nr, all_lyv_lines, bars_dict)
			elif not recursive:
				feed_model(duo, composer, bar_nr, all_lyv_lines, bars_dict)
			else:
				feed_model(duo)
		num_notes_to_query = num_notes[0]
		if duo and i % 2 == 1: num_notes_to_query = num_notes[1]
		print("prompt events done, querying...")
		lyv_str = query(client, duo, num_notes_to_query)
		clear_lists = False
		if lyv_str is not None:
			for string in lyv_str:
				lyv_strings.append(string)
			if not duo and len(lyv_strings) > 0:
				type_lyv_strigs(client, duo, lyv_strings)
				clear_lists = True
			elif duo and i % 2 == 1 and len(lyv_strings) > 0:
				type_lyv_strigs(client, duo, lyv_strings)
				clear_lists = True
			time.sleep(OSCDEL)
		if clear_lists:
			lyv_strings = []
			written_base_insts = []
			written_secondary_insts = []
		time.sleep(OSCDEL)
	type_loop_str(client, start_of_loop)


def from_barlines(address, fixed_args, *osc_args):
	global gen_lines, barnum
	# stall the function while the ctrl key is pressed to avoid confusion
	while ctrl_pressed_l or ctrl_pressed_r:
		print("ctrl pressed, waiting...")
		time.sleep(0.1)
	# print a blank line to separate data
	print()
	client = fixed_args[0]
	duo = fixed_args[1]
	num_notes = [0, 0]
	gen_lines = []
	barlines = []
	start_of_loop = barnum
	recursive = False
	num_bar_provided = False
	num_notes_provided = False
	num_notes_second_provided = False
	if len(osc_args) < 3:
		error_str = '% too few arguments, needs num_bars num_notes barlines ["r"]'
		for ch in error_str:
			client.send_message("/livelily2/press", ch)
		execute_line(client)
		return None
	for i,v in enumerate(osc_args):
		if type(v) is int:
			if i == 0:
				num_bars = v
				num_bars_provided = True
			elif i == 1:
				num_notes[0] = v
				num_notes_provided = True
			elif i == 2:
				num_notes[1] = v
				num_notes_second_provided = True
		else:
			if not num_bars_provided or not num_notes_provided:
				if not num_bars_provided: error_str = "% number of bars not provided"
				else: error_str = "% number of notes not provided"
				for ch in error_str:
					client.send_message("/livelily2/press", ch)
				execute_line(client)
				return None
			if not num_notes_second_provided: num_notes[1] = num_notes[0]
			if v == "r": recursive = True
			else: barlines.append(v)
	print(f"num notes: {num_notes}")
	lyv_strings = []
	# if we're generating bars for each instrument twice, we need to isolate the first instruments
	barlines_mono = []
	if duo:
		# if we're writing for a duo (twice the defined instruments), empty the list below so it's useable in translate_to_livelily()
		written_base_insts = []
		written_secondary_insts = []
		num_bars *= 2
		for i in range(len(barlines)):
			# isolate the instrument name and remove the 1 or 2 that is appended to it
			space_ndx = barlines[i][4:].find(" ")
			space_ndx += 4 # add the horizontal tab
			if barlines[i][4:space_ndx-1] in insts.keys():
				inst_name = barlines[i][4:space_ndx]
				inst_ndx = inst_name[-1]
				if inst_ndx == "1":
					barlines_mono.append(inst_name[:-1] + barlines[i][space_ndx:])
			else:
				barlines_mono.append(barlines[i])
	else:
		barlines_mono = barlines.copy()
	for i in range(num_bars):
		if i == 0 or len(gen_lines) == 0:
			feed_model(duo, barlines_mono)
		elif not recursive:
			feed_model(duo, barlines_mono)
		else:
			feed_model(duo)
		num_notes_to_query = num_notes[0]
		if duo and i % 2 == 1: num_notes_to_query = num_notes[1]
		print("prompt events done, querying...")
		lyv_str = query(client, duo, num_notes_to_query)
		clear_lists = False
		if lyv_str is not None:
			for string in lyv_str:
				lyv_strings.append(string)
			if not duo and len(lyv_strings) > 0:
				type_lyv_strigs(client, duo, lyv_strings)
				clear_lists = True
			elif duo and i % 2 == 1 and len(lyv_strings) > 0:
				type_lyv_strigs(client, duo, lyv_strings)
				clear_lists = True
			time.sleep(OSCDEL)
		if clear_lists:
			lyv_strings = []
			written_base_insts = []
			written_secondary_insts = []
		time.sleep(OSCDEL)
	type_loop_str(client, start_of_loop)


def type_loop_str(client, start_of_loop):
	global barnum, loop_names
	# if we manage to create more than one bar
	if start_of_loop < barnum - 1:
		end_of_loop = barnum - 1
		loop_name = "nn" + str(start_of_loop) + "-" + str(end_of_loop)
		loop_str = "\\loop " + loop_name + " { "
		for i in range(end_of_loop - start_of_loop + 1):
			loop_str += "\\nn" + str(start_of_loop + i) + " "
		loop_str += "}"
		# don't add the loop name as the LiveLily part behaves weird when this is in the same line, have to fix this
		#loop_str += loop_name
		for ch in loop_str:
			client.send_message("/livelily2/press", ch)
		execute_line(client)
		time.sleep(OSCDEL)
		# type and execute the loop name separately (for now)
		loop_name = "\\" + loop_name
		for ch in loop_name:
			client.send_message("/livelily2/press", ch)
		execute_line(client)
		loop_names.append(loop_name)
		# set the stops as arguments to the function that sends the Program Change messages
		#arg_str = "\\stops setargs "
	elif start_of_loop == barnum - 1:
		# don't include single bars for now
		#bar_name = "\\nn" + str(start_of_loop)
		bar_name = "% one bar only, omitting..."
		for ch in bar_name:
			client.send_message("/livelily2/press", ch)
		execute_line(client)
	elif start_of_loop == barnum:
		comment = "% recursion error"
		for ch in comment:
			client.send_message("/livelily2/press", ch)
		execute_line(client)


def execute_line(client):
	client.send_message("/livelily2/press", 1)
	client.send_message("/livelily2/press", 13)
	client.send_message("/livelily2/release", 1)
	client.send_message("/livelily2/press", 13)


def feed_model(*args):
	duo = args[0]
	if len(args) == 5:
		# if we provide five arguments, we want to feed Notochord a certain bar from a certain composer
		composer = args[1]
		bar_nr = args[2]
		all_lyv_lines = args[3]
		bars_dict = args[4]
		parsed_data, numer, tempo_ms, chord_notes = parse_bar(duo, composer, bar_nr, all_lyv_lines, bars_dict)
	elif len(args) == 2:
		# if we provide two arguments, we provide strings of a bar defined in LiveLily
		barlines = args[1]
		parsed_data, numer, tempo_ms, chord_notes = parse_bar(duo, barlines)
	else:
		# if we provide two arguments, we want to feed Notochord its previous output
		parsed_data, numer, tempo_ms, chord_notes = parse_bar(duo)
	# MIDI events have to be sorted according to when they occur
	# this means that if all staves have a note on the first downbeat
	# then the first events to be fed to the model must be the first note of each staff, in order
	# the rest of the events follow the same philosophy, so we need to sort data based on time
	events = get_sorted_events(parsed_data, numer, tempo_ms, chord_notes)
	# once sorted, we need to get back to the original delta time
	# so inverse the accumulation we did earlier (we needed the accumulation to properly sort the events)
	prev_time = -1
	for i,event in enumerate(events):
		prev_temp = event[3]
		if event[3] == prev_time:
			event[3] = 0
		else:
			if i == 0 and event[3] == 0:
				event[3] = 0 # 0.25 * tempo_ms # note off duration of one quarter
			else:
				event[3] -= prev_time
		prev_time = prev_temp
		events[i] = event
	model.reset()
	print("prompt events:")
	for event in events:
		print(event)
		model.feed(event[0], event[2], event[3]*0.001, event[4])


def query(client, duo, num_notes):
	accum_events = []
	#notes = []
	for i in range(num_notes):
		query = model.query_feed(include_pitch=included_pitches)
		args = [(query['inst']-INITINST) % NUMINSTS, query['pitch'], int(query['vel']), int(query['time']*1000)]
		#notes.append([query['inst']-INITINST, query['pitch'], int(query['vel'])])
		accum_events.append(args)
		print(args)
	print("queries done")
	lyv_strings = translate_to_livelily(accum_events, duo)
	#find_hanging(notes, client)
	return lyv_strings


def get_loop_name(address, fixed_args, *args):
	client = fixed_args[0]
	loop_name = loop_names[args[0]]
	for ch in loop_name:
		client.send_message("/livelily1/press", ch)
	client.send_message("/livelily1/press", 13)


def quit_script(address, fixed_args, *args):
	print("quitting...")
	fixed_args[0].shutdown()
	exit()


def main():
	global insts, insts_rev, NUMINSTS
	parser = argparse.ArgumentParser()
	parser.add_argument("--insts", nargs="*", help="instruments to create scores for")
	parser.add_argument("--lyv_dir", help="the directory to read LiveLily files from")
	parser.add_argument("--duo", help="define if the network must create scores for a duo")
	args = parser.parse_args()

	if args.insts is None:
		raise argparse.ArgumentTypeError("No instruments specified")

	duo = False
	if args.duo is not None:
		duo = True

	for i,arg in enumerate(args.insts):
		insts["\\"+arg] = [INITINST+i]
		insts_rev[i] = "\\"+arg
	NUMINSTS = len(insts)
	if duo: NUMINSTS *= 2

	listener = keyboard.Listener(on_press=on_press, on_release=on_release)
	listener.start()

	bars_dict = dict()
	all_lyv_lines = dict()
	if args.lyv_dir is None:
		lyv_dir = "lyv_files"
	else:
		lyv_dir = args.lyv_dir
	for file in glob.glob(lyv_dir+"/*.lyv"):
		glob_composer = file[file.find("/")+1:file.find(".")]
		bars_dict[glob_composer] = dict()
		f = open(file, "r")
		all_lyv_lines[glob_composer] = f.readlines()
		f.close()
		bars_dict[glob_composer] = store_bar_lines(glob_composer, all_lyv_lines[glob_composer])

	client = osc_client("127.0.0.1", 9050)
	dispat = Dispatcher()
	server = osc_server.ThreadingOSCUDPServer(("127.0.0.1", 9010), dispat)
	dispat.map("/generate", generate, all_lyv_lines, bars_dict, client, duo)
	dispat.map("/barlines", from_barlines, client, duo)
	dispat.map("/loopname", get_loop_name, client)
	dispat.map("/quit", quit_script, server)

	print(f"Serving on {server.server_address}...")
	server.serve_forever()


if __name__ == "__main__":
	main()
